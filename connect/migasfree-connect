#!/usr/bin/python3
"""
migasfree-connect - Multi-protocol Tunnel Client (SSH, VNC, RDP, etc.)

This client establishes secure WebSocket connections to relay servers,
enabling remote access to migasfree agents through mTLS authentication.
"""

from __future__ import annotations

import asyncio
import getpass
import json
import logging
import os
import re
import ssl
import subprocess
import sys
import uuid
from contextlib import suppress
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from urllib.parse import urlparse

import requests
import urllib3
import websockets

# Optional migasfree-client integration
try:
    from migasfree_client import settings
    from migasfree_client.utils import get_config
    FQDN = get_config(settings.CONF_FILE, 'client').get('server', '')
except ImportError:
    FQDN = ''

# Disable SSL warnings when CA is not provided
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
)
logger = logging.getLogger(__name__)

# Constants
BUFFER_SIZE = 8192
CONNECTION_TIMEOUT = 5
WEBSOCKET_CONFIG = {
    'ping_interval': 20,
    'ping_timeout': 60,
    'close_timeout': 10,
    'max_size': 10**7,
}


def extract_cn_from_cert(cert_path: str) -> Optional[str]:
    """Extracts the Common Name (CN) from the certificate."""
    if not cert_path or not os.path.exists(cert_path):
        return None
    try:
        cmd = ['openssl', 'x509', '-in', cert_path, '-noout', '-subject']
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        subject = result.stdout.strip()

        match = re.search(r'CN\s*=\s*([^/,]+)', subject)
        if match:
            return match.group(1).strip()

        if subject.startswith('subject='):
            return subject[8:].strip()
        return subject
    except (subprocess.CalledProcessError, OSError):
        return None


def check_credentials(manager_url: str) -> Tuple[Optional[str], Optional[str], Optional[str]]:
    """Checks for mTLS credentials or extracts them from a .p12 file."""
    try:
        parsed = urlparse(manager_url)
        fqdn = parsed.hostname or ''
    except ValueError:
        fqdn = ''

    if manager_url == 'https://':
        print('‚ùå Invalid Manager URL. Please provide a valid URL.')
        print('   Example: migasfree-connect -a CID-4 -t ssh -m https://<FQDN> <user>')
        sys.exit(1)

    home = Path.home()
    cert_dir = home / '.migasfree-connect' / fqdn
    cert_dir.mkdir(parents=True, exist_ok=True)

    cert_file = cert_dir / 'cert.pem'
    key_file = cert_dir / 'key.pem'
    ca_file = cert_dir / 'ca.pem'

    if cert_file.exists() and key_file.exists():
        return str(cert_file), str(key_file), str(ca_file) if ca_file.exists() else None

    print('\nüîê mTLS Credentials missing. Please provide a .p12 certificate (e.g., admin.p12)')

    while True:
        p12_path = input('üëâ Path to .p12 file: ').strip()
        p12_file = Path(p12_path)
        if p12_file.exists() and p12_file.is_file():
            break
        print('‚ùå File not found. Try again.')

    password = getpass.getpass('üëâ .p12 Password: ')

    print('‚öôÔ∏è Extracting certificates...')

    cmd_cert = [
        'openssl', 'pkcs12', '-in', str(p12_file),
        '-clcerts', '-nokeys', '-out', str(cert_file),
        '-passin', f'pass:{password}'
    ]

    cmd_key = [
        'openssl', 'pkcs12', '-in', str(p12_file),
        '-nocerts', '-out', str(key_file), '-nodes',
        '-passin', f'pass:{password}'
    ]

    cmd_ca = [
        'openssl', 'pkcs12', '-in', str(p12_file),
        '-cacerts', '-nokeys', '-out', str(ca_file),
        '-passin', f'pass:{password}'
    ]

    try:
        subprocess.run(cmd_cert, check=True, capture_output=True)
        subprocess.run(cmd_key, check=True, capture_output=True)
        subprocess.run(cmd_ca, check=False, capture_output=True)

        print(f'‚úÖ Credentials extracted to {cert_dir}')
        ca_result = str(ca_file) if ca_file.exists() and ca_file.stat().st_size > 0 else None
        return str(cert_file), str(key_file), ca_result

    except subprocess.CalledProcessError as e:
        print(f'‚ùå Error extracting certificates. Wrong password?\n{e}')
        sys.exit(1)

class MultiProtocolTunnel:
    """
    Client that creates TCP tunnels through WebSocket connections.

    Supports multiple protocols (SSH, VNC, RDP, etc.) by forwarding
    local ports through a secure relay server.
    """

    def __init__(
        self,
        manager_url: str,
        user: Optional[str] = None,
        agent_id: Optional[str] = None,
        local_port: int = 0,
        service: str = 'ssh',
        msg_cert: Optional[str] = None,
        msg_key: Optional[str] = None,
        msg_ca: Optional[str] = None,
    ):
        self.manager_url = manager_url.rstrip('/')
        self.user = user
        self.target_agent_id = agent_id
        self.local_port = local_port or self._find_free_port()
        self.service = service
        self.tunnel_task = None
        self.server: Optional[asyncio.AbstractServer] = None
        self.client_process: Optional[subprocess.Popen] = None
        self.active = False
        self.selected_agent: Optional[Dict] = None
        self.relay_url: Optional[str] = None

        # Active connections tracking
        self.active_connections: Dict[str, Dict] = {}

        # mTLS Credentials
        self.cert = msg_cert
        self.key = msg_key
        self.ca = msg_ca
        self.client_cn = extract_cn_from_cert(self.cert) if self.cert else None

    @staticmethod
    def _find_free_port() -> int:
        """Finds a free port automatically."""
        import socket
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.bind(('', 0))
            s.listen(1)
            return s.getsockname()[1]

    async def select_agent(self) -> Optional[Dict]:
        """Selects an agent from the manager."""
        print(f'üìã Querying Manager at {self.manager_url}')
        try:
            verify_param = self.ca if self.ca else False
            cert_param = (self.cert, self.key) if self.cert and self.key else None

            resp = requests.get(
                f'{self.manager_url}/manager/v1/private/tunnel/agents',
                timeout=CONNECTION_TIMEOUT,
                verify=verify_param,
                cert=cert_param,
            )
            resp.raise_for_status()
            data = resp.json()
            agents = data.get('agents', [])
        except requests.RequestException as e:
            print(f'‚ùå Error contacting Manager: {e}')
            return None

        if not agents:
            print('‚ùå No agents available')
            return None

        # If an agent was specified, search for it immediately
        if self.target_agent_id:
            for agent in agents:
                if self.target_agent_id in agent['agent_id']:
                    print(f'\n‚úÖ Agent selected: {agent["hostname"]}')
                    return agent
            print(f'‚ùå Agent {self.target_agent_id} not found in current list')
            return None

        print(f'\nüìä Available Agents ({len(agents)}):')
        for idx, agent in enumerate(agents, 1):
            info = agent.get('info', {})
            services = info.get('available_services', [])
            services_str = f' [{", ".join(services)}]' if services else ''
            print(f'   [{idx}] {agent["hostname"]}{services_str}')
            print(f'       ID: {agent["agent_id"][:24]}...')
            print(f'       OS: {info.get("system", "N/A")} {info.get("architecture", "")}')

        # If there is only one agent, use it automatically
        if len(agents) == 1:
            agent = agents[0]
            print(f'\n‚úÖ Using: {agent["hostname"]}')
            return agent

        # Multiple agents: ask for selection
        while True:
            try:
                selection = input(f'\nüëâ Select an agent [1-{len(agents)}]: ').strip()
                idx = int(selection) - 1
                if 0 <= idx < len(agents):
                    agent = agents[idx]
                    print(f'‚úÖ Selected: {agent["hostname"]}')
                    return agent
                print('‚ùå Invalid number')
            except ValueError:
                print('‚ùå Enter a valid number')
            except KeyboardInterrupt:
                print('\n‚ùå Cancelled by user')
                return None

    async def handle_tcp_client(self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter) -> None:
        """Handles a TCP tunnel connection."""
        tunnel_id = f'cli-{uuid.uuid4()}'
        print(f'üîó Tunnel established: {tunnel_id}')

        ws = None

        try:
            # Prepare headers for HAProxy sticky sessions
            extra_headers: Dict[str, str] = {}
            if self.selected_agent:
                extra_headers['X-Agent-ID'] = self.selected_agent['agent_id']
                if 'server_ip' in self.selected_agent:
                    extra_headers['X-Server-IP'] = self.selected_agent['server_ip']

            print(f'üîå Connecting to Relay: {self.relay_url}')

            # Prepare connection kwargs
            connect_kwargs = WEBSOCKET_CONFIG.copy()

            # Configure SSL context for wss://
            if self.relay_url.startswith('wss://'):
                if self.ca:
                    ssl_context = ssl.create_default_context(cafile=self.ca)
                else:
                    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
                    ssl_context.check_hostname = False
                    ssl_context.verify_mode = ssl.CERT_NONE

                if self.cert and self.key:
                    ssl_context.load_cert_chain(certfile=self.cert, keyfile=self.key)

                connect_kwargs['ssl'] = ssl_context
            
            # Try to connect with headers - handle different websockets versions
            if extra_headers:
                try:
                    # Try extra_headers first (older versions)
                    connect_kwargs['extra_headers'] = extra_headers
                    ws = await asyncio.wait_for(
                        websockets.connect(self.relay_url, **connect_kwargs),
                        timeout=5
                    )
                except TypeError as e:
                    if 'extra_headers' in str(e):
                        # Fallback to additional_headers (newer versions)
                        del connect_kwargs['extra_headers']
                        connect_kwargs['additional_headers'] = extra_headers
                        ws = await asyncio.wait_for(
                            websockets.connect(self.relay_url, **connect_kwargs),
                            timeout=5
                        )
                    else:
                        raise
            else:
                ws = await asyncio.wait_for(
                    websockets.connect(self.relay_url, **connect_kwargs),
                    timeout=5
                )

            # Identify as tunnel client
            await ws.send(json.dumps({
                'type': 'connect_client',
                'mode': 'tcp_tunnel',
            }))
            await ws.recv()

            if not self.selected_agent:
                print('‚ùå No agent selected')
                writer.close()
                await writer.wait_closed()
                return

            agent_id = self.selected_agent['agent_id']

            # Request TCP tunnel with specified service
            await ws.send(json.dumps({
                'type': 'start_tcp_tunnel',
                'agent_id': agent_id,
                'tunnel_id': tunnel_id,
                'service': self.service,
                'client_cn': self.client_cn
            }))

            resp = await asyncio.wait_for(ws.recv(), timeout=10)
            resp_data = json.loads(resp)

            if resp_data.get('type') != 'tunnel_started':
                print(f'‚ùå Error starting tunnel: {resp_data.get("message")}')
                writer.close()
                await writer.wait_closed()
                return

            # Bidirectional forwarding
            async def tcp_to_ws() -> None:
                try:
                    while self.active:
                        data = await reader.read(BUFFER_SIZE)
                        if not data:
                            break
                        await ws.send(json.dumps({
                            'type': 'tunnel_data',
                            'tunnel_id': tunnel_id,
                            'data': data.hex(),
                        }))
                except asyncio.CancelledError:
                    pass
                except Exception:  # noqa: BLE001
                    pass

            async def ws_to_tcp():
                try:
                    async for msg in ws:
                        if not self.active:
                            break

                        message = json.loads(msg)

                        if message.get('type') == 'tunnel_data':
                            data_hex = message.get('data', '')
                            if data_hex:
                                data = bytes.fromhex(data_hex)
                                writer.write(data)
                                await writer.drain()

                        elif message.get('type') == 'tunnel_closed':
                            break
                except asyncio.CancelledError:
                    pass
                except Exception:
                    pass

            # Create tasks and register connection
            task_tcp = asyncio.ensure_future(tcp_to_ws())
            task_ws = asyncio.ensure_future(ws_to_tcp())
            
            self.active_connections[tunnel_id] = {
                'ws': ws,
                'writer': writer,
                'tasks': [task_tcp, task_ws]
            }

            await asyncio.gather(task_tcp, task_ws, return_exceptions=True)

        except asyncio.CancelledError:
            pass
        except Exception as e:  # noqa: BLE001
            if self.active:
                print(f'‚ùå Error in tunnel: {e}')
        finally:
            # Remove from active connections
            self.active_connections.pop(tunnel_id, None)
            
            # Close WebSocket
            if ws is not None:
                try:
                    if hasattr(ws, 'open') and ws.open:
                        await ws.send(json.dumps({
                            'type': 'close_tunnel',
                            'tunnel_id': tunnel_id
                        }))
                    await ws.close()
                except Exception:
                    pass

            # Close TCP
            try:
                writer.close()
                await writer.wait_closed()
            except Exception:
                pass

    async def start_tunnel(self) -> None:
        """Starts the tunnel server."""
        self.server = await asyncio.start_server(
            self.handle_tcp_client,
            '127.0.0.1',
            self.local_port,
        )
        self.active = True
        print(f'‚úÖ Tunnel listening on port {self.local_port}')

    async def stop_tunnel(self) -> None:
        """Stops the tunnel server and all active connections."""
        self.active = False

        # Close all active connections
        for tunnel_id, conn in list(self.active_connections.items()):
            for task in conn.get('tasks', []):
                if not task.done():
                    task.cancel()

            ws = conn.get('ws')
            if ws:
                with suppress(Exception):
                    await ws.close()

            writer = conn.get('writer')
            if writer:
                with suppress(Exception):
                    writer.close()
                    await writer.wait_closed()

        self.active_connections.clear()

        if self.server:
            self.server.close()
            await self.server.wait_closed()
            print('üîå Tunnel closed')

    def execute_client(self, extra_command: Optional[List[str]] = None) -> int:
        """Executes the appropriate client according to the service and platform."""
        is_windows = sys.platform == 'win32'

        if self.service == 'ssh':
            if not self.user:
                print('‚ùå User required for SSH')
                return 1

            cmd = [
                'ssh',
                '-p', str(self.local_port),
                '-o', 'StrictHostKeyChecking=no',
                '-o', 'UserKnownHostsFile=/dev/null',
                '-o', 'LogLevel=ERROR',
                '-o', 'ServerAliveInterval=30',
                '-o', 'ServerAliveCountMax=3',
                '-o', 'TCPKeepAlive=yes',
                '-o', 'NoHostAuthenticationForLocalhost=yes',
                '-o', 'CheckHostIP=no',
                f'{self.user}@127.0.0.1',
            ]
            if extra_command:
                cmd.extend(extra_command)
            print('\nüöÄ Connecting SSH...')

        elif self.service == 'vnc':
            if is_windows:
                # Try common Windows VNC viewers
                cmd = ['vncviewer', f'localhost:{self.local_port}']
            else:
                cmd = ['vncviewer', f'localhost:{self.local_port}']
            print('\nüñ•Ô∏è  Connecting VNC...')

        elif self.service == 'rdp':
            if is_windows:
                # Windows native RDP client
                cmd = ['mstsc', f'/v:localhost:{self.local_port}']
            else:
                # Linux: xfreerdp
                cmd = ['xfreerdp', f'/v:localhost:{self.local_port}', '/cert-ignore', '/clipboard', '/sound']
                if self.user:
                    cmd.append(f'/u:{self.user}')
            print('\nüñ•Ô∏è  Connecting RDP...')

        else:
            print(f'‚ö†Ô∏è  Service "{self.service}" has no predefined client')
            print(f'   Tunnel available at localhost:{self.local_port}')
            print('   Press Ctrl+C to close...')
            try:
                import time
                while True:
                    time.sleep(1)
            except KeyboardInterrupt:
                return 0
            return 0

        print(f'   Command: {" ".join(cmd)}\n')
        print('=' * 70)

        try:
            self.client_process = subprocess.Popen(cmd)
            return self.client_process.wait()
        except KeyboardInterrupt:
            print('\n‚ö†Ô∏è  Connection interrupted by user')
            if self.client_process:
                self.client_process.terminate()
            return 1
        except FileNotFoundError:
            print(f'‚ùå Client {self.service.upper()} not found')
            if self.service == 'ssh':
                if is_windows:
                    print('   üëâ Install OpenSSH or use Windows Terminal')
                else:
                    print('   üëâ Install: sudo apt install openssh-client')
            elif self.service == 'vnc':
                if is_windows:
                    print('   üëâ Install a VNC viewer like TightVNC or RealVNC')
                else:
                    print('   üëâ Install: sudo apt install xtightvncviewer')
            elif self.service == 'rdp':
                if is_windows:
                    print('   üëâ mstsc.exe should be available by default')
                else:
                    print('   üëâ Install: sudo apt install freerdp2-x11')
            return 1

    async def connect(self, extra_command: Optional[List[str]] = None) -> int:
        """Complete flow: select agent, open tunnel, connect client, close tunnel."""
        print('=' * 70)
        print(f'üîê Tunnel {self.service.upper()} over WebSocket')
        print('=' * 70)

        try:
            agent = await self.select_agent()
            if not agent:
                return 1

            self.target_agent_id = agent['agent_id']
            self.selected_agent = agent

            self.relay_url = agent.get('relay_url') or agent.get('server_url')
            if not self.relay_url:
                print('‚ùå Agent has no registered Relay URL')
                return 1

            print(f'‚úÖ Route: Client -> {self.relay_url} -> Agent')

            print(f'\nüîß Starting TCP tunnel on port {self.local_port}...')
            await self.start_tunnel()

            await asyncio.sleep(0.5)

            loop = asyncio.get_event_loop()
            exit_code = await loop.run_in_executor(
                None,
                self.execute_client,
                extra_command,
            )

            print('\n' + '=' * 70)
            print(f'‚úÖ Session {self.service.upper()} finished')

            return exit_code

        except Exception as e:  # noqa: BLE001
            print(f'‚ùå Error: {e}')
            import traceback
            traceback.print_exc()
            return 1
        finally:
            await self.stop_tunnel()
            print('=' * 70)


async def main_async() -> int:
    """Async main entry point."""
    import argparse

    parser = argparse.ArgumentParser(
        description='Multi-Protocol Client over WebSocket (SSH, VNC, RDP)',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  %(prog)s -t ssh -a CID-4 -m https://<FQDN> root  # SSH to agent
  %(prog)s -t ssh -a CID-4 -m https://<FQDN> root -c "ls -la"  # Execute remote command
  %(prog)s -t vnc -a CID-4 -m https://<FQDN>  # Connect VNC
  %(prog)s -t rdp -a CID-4 -m https://<FQDN> tux  # Connect RDP
        ''',
    )

    parser.add_argument('user', nargs='?', help='User for SSH/RDP (optional for VNC)')
    parser.add_argument('-t', '--type', default='ssh', choices=['ssh', 'vnc', 'rdp'],
                        help='Service type (ssh, vnc, rdp)')
    parser.add_argument('-a', '--agent', help='Agent ID (or part of ID)')
    parser.add_argument('-m', '--manager', default=f'https://{FQDN}', help='Manager API URL')
    parser.add_argument('-p', '--port', type=int, default=0,
                        help='Local port for tunnel (0 = automatic)')
    parser.add_argument('-c', '--command', help='Command to execute remotely (SSH only)')

    args = parser.parse_args()

    if args.type == 'ssh' and not args.user:
        parser.error('User required for SSH')

    extra_command = [args.command] if args.command else None

    credentials = check_credentials(args.manager)
    msg_cert, msg_key, msg_ca = credentials if credentials else (None, None, None)

    tunnel = MultiProtocolTunnel(
        manager_url=args.manager,
        user=args.user,
        agent_id=args.agent,
        local_port=args.port,
        service=args.type,
        msg_cert=msg_cert,
        msg_key=msg_key,
        msg_ca=msg_ca,
    )

    return await tunnel.connect(extra_command)


def main() -> None:
    """Main entry point."""
    try:
        exit_code = asyncio.run(main_async())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print('\n\n‚úÖ Cancelled by user')
        sys.exit(130)


if __name__ == '__main__':
    main()
